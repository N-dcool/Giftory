{"version":3,"file":"subtitle.cjs.production.min.js","sources":["../src/utils.ts","../src/formatTimestamp.ts","../src/map.ts","../src/Parser.ts","../src/parseTimestamp.ts","../src/parseTimestamps.ts","../src/Formatter.ts","../src/filter.ts","../src/parse.ts","../src/parseSync.ts","../src/resync.ts","../src/stringify.ts","../src/stringifySync.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'stream'\n\nexport const padLeft = (value: number, length = 2): string =>\n  value.toString().padStart(length, '0')\n\nexport const createDuplex = (options: DuplexOptions) =>\n  new Duplex({\n    objectMode: true,\n    autoDestroy: false,\n    read() {},\n    ...options\n  })\n","import { padLeft } from './utils'\nimport { FormatOptions } from '.'\n\nexport function formatTimestamp(\n  timestamp: number,\n  options: FormatOptions = { format: 'SRT' }\n) {\n  const date = new Date(0, 0, 0, 0, 0, 0, timestamp)\n\n  const hours = date.getHours()\n  const minutes = date.getMinutes()\n  const seconds = date.getSeconds()\n  const ms = Math.floor(\n    timestamp - (hours * 3600000 + minutes * 60000 + seconds * 1000)\n  )\n\n  return `${padLeft(hours)}:${padLeft(minutes)}:${padLeft(seconds)}${\n    options.format === 'WebVTT' ? '.' : ','\n  }${padLeft(ms, 3)}`\n}\n","import { Transform } from 'stream'\nimport { Node } from '.'\n\nexport const map = (mapper: (node: Node, index: number) => any) => {\n  let index = 0\n\n  return new Transform({\n    objectMode: true,\n    autoDestroy: false,\n    transform(chunk: Node, _encoding, callback) {\n      callback(null, mapper(chunk, index++))\n    }\n  })\n}\n","import stripBom from 'strip-bom'\nimport { Node, RE_TIMESTAMP, parseTimestamps } from '.'\n\nexport type Pusher = (node: Node) => void\n\nexport interface ParseState {\n  expect: 'header' | 'id' | 'timestamp' | 'text' | 'vtt_comment'\n  row: number\n  hasContentStarted: boolean\n  isWebVTT: boolean\n  node: Partial<Node>\n  buffer: string[]\n}\n\nexport class Parser {\n  private push: Pusher\n  private state: ParseState\n\n  constructor({ push }: { push: Pusher }) {\n    this.push = push\n    this.state = {\n      expect: 'header',\n      row: 0,\n      hasContentStarted: false,\n      isWebVTT: false,\n      node: {},\n      buffer: []\n    }\n  }\n\n  private isIndex(line: string): boolean {\n    return /^\\d+$/.test(line.trim())\n  }\n\n  private isTimestamp(line: string): boolean {\n    return RE_TIMESTAMP.test(line)\n  }\n\n  private isVttComment(line: string): boolean {\n    return /^NOTE/.test(line)\n  }\n\n  private getError(expected: string, index: number, row: string): Error {\n    return new Error(\n      `expected ${expected} at row ${index + 1}, but received: \"${row}\"`\n    )\n  }\n\n  public parseLine(line: string): void {\n    const contents = this.state.row === 0 ? stripBom(line) : line\n\n    if (!this.state.hasContentStarted) {\n      if (contents.trim()) {\n        this.state.hasContentStarted = true\n      } else {\n        return\n      }\n    }\n\n    const parse = {\n      header: this.parseHeader,\n      id: this.parseId,\n      timestamp: this.parseTimestamp,\n      text: this.parseText,\n      vtt_comment: this.parseVttComment\n    }[this.state.expect]\n\n    parse.call(this, contents)\n\n    this.state.row++\n  }\n\n  public flush(): void {\n    if (this.state.buffer.length > 0) {\n      this.pushNode()\n    }\n  }\n\n  private parseHeader(line: string) {\n    if (!this.state.isWebVTT) {\n      this.state.isWebVTT = /^WEBVTT/.test(line)\n\n      if (this.state.isWebVTT) {\n        this.state.node.type = 'header'\n      } else {\n        this.parseId(line)\n        return\n      }\n    }\n\n    this.state.buffer.push(line)\n\n    if (!line) {\n      this.state.expect = 'id'\n      return\n    }\n  }\n\n  private parseId(line: string) {\n    this.state.expect = 'timestamp'\n\n    if (this.state.node.type === 'header') {\n      this.pushNode()\n    }\n\n    if (this.isIndex(line)) return\n\n    if (this.state.isWebVTT && this.isVttComment(line)) {\n      this.state.expect = 'vtt_comment'\n      return\n    }\n\n    this.parseTimestamp(line)\n  }\n\n  private parseVttComment(line: string) {\n    this.state.expect = 'vtt_comment'\n\n    if (line.trim() === '') {\n      this.state.expect = 'id'\n    }\n  }\n\n  private parseTimestamp(line: string) {\n    if (!this.isTimestamp(line)) {\n      throw this.getError('timestamp', this.state.row, line)\n    }\n\n    this.state.node = {\n      type: 'cue',\n      data: {\n        ...parseTimestamps(line),\n        text: ''\n      }\n    }\n\n    this.state.expect = 'text'\n  }\n\n  private parseText(line: string) {\n    if (this.state.buffer.length === 0) {\n      this.state.buffer.push(line)\n      return\n    }\n\n    if (this.isTimestamp(line)) {\n      const lastIndex = this.state.buffer.length - 1\n\n      if (this.isIndex(this.state.buffer[lastIndex])) {\n        this.state.buffer.pop()\n      }\n\n      this.pushNode()\n      this.parseTimestamp(line)\n      return\n    }\n\n    if (this.isVttComment(line)) {\n      this.pushNode()\n      this.parseVttComment(line)\n      return\n    }\n\n    this.state.buffer.push(line)\n  }\n\n  private pushNode(): void {\n    if (this.state.node.type === 'cue') {\n      while (true) {\n        const lastItem = this.state.buffer[this.state.buffer.length - 1]\n        if (['', '\\n'].includes(lastItem)) {\n          this.state.buffer.pop()\n        } else {\n          break\n        }\n      }\n\n      while (true) {\n        const firstItem = this.state.buffer[0]\n        if (['', '\\n'].includes(firstItem)) {\n          this.state.buffer.shift()\n        } else {\n          break\n        }\n      }\n\n      this.state.node.data!.text = this.state.buffer.join('\\n')\n    }\n\n    if (this.state.node.type === 'header') {\n      this.state.node.data = this.state.buffer.join('\\n').trim()\n    }\n\n    this.push(this.state.node as Node)\n\n    this.state.node = {}\n    this.state.buffer = []\n  }\n}\n","export function parseTimestamp(timestamp: string): number {\n  const match = timestamp.match(\n    /^(?:(\\d{1,}):)?(\\d{1,2}):(\\d{1,2})[,.](\\d{1,3})$/\n  )\n\n  if (!match) {\n    throw new Error('Invalid SRT or VTT time format: \"' + timestamp + '\"')\n  }\n\n  const hours = match[1] ? parseInt(match[1], 10) * 3600000 : 0\n  const minutes = parseInt(match[2], 10) * 60000\n  const seconds = parseInt(match[3], 10) * 1000\n  const milliseconds = parseInt(match[4], 10)\n\n  return hours + minutes + seconds + milliseconds\n}\n","import { parseTimestamp, Timestamp } from '.'\n\nexport const RE_TIMESTAMP = /^((?:\\d{1,}:)?\\d{1,2}:\\d{1,2}[,.]\\d{1,3}) --> ((?:\\d{1,}:)?\\d{1,2}:\\d{1,2}[,.]\\d{1,3})(?: (.*))?$/\n\nexport function parseTimestamps(value: string): Timestamp {\n  const match = RE_TIMESTAMP.exec(value)\n\n  if (!match) {\n    throw new Error('Invalid timestamp format')\n  }\n\n  const timestamp: Timestamp = {\n    start: parseTimestamp(match[1]),\n    end: parseTimestamp(match[2])\n  }\n\n  if (match[3]) {\n    timestamp.settings = match[3]\n  }\n\n  return timestamp\n}\n","import { FormatOptions, Node, Cue, formatTimestamp } from '.'\n\nexport class Formatter {\n  private options: FormatOptions\n  private isVTT: boolean\n  private hasReceivedHeader: boolean\n  private index: number\n\n  constructor(options: FormatOptions) {\n    this.options = options\n    this.hasReceivedHeader = false\n    this.isVTT = options.format === 'WebVTT'\n    this.index = 1\n  }\n\n  public format(node: Node): string {\n    let buffer = ''\n\n    if (node.type === 'header' && this.isVTT) {\n      this.hasReceivedHeader = true\n      buffer += `${node.data}\\n\\n`\n    }\n\n    if (node.type === 'cue') {\n      if (!this.hasReceivedHeader && this.isVTT) {\n        this.hasReceivedHeader = true\n        buffer += 'WEBVTT\\n\\n'\n      }\n\n      buffer += this.formatCue(node.data, this.index++, this.options)\n    }\n\n    return buffer\n  }\n\n  private formatCue(cue: Cue, index: number, options: FormatOptions) {\n    return [\n      `${index > 1 ? '\\n' : ''}${index}`,\n      `${formatTimestamp(cue.start, options)} --> ${formatTimestamp(\n        cue.end,\n        options\n      )}${\n        options.format === 'WebVTT' && cue.settings ? ' ' + cue.settings : ''\n      }`,\n      cue.text,\n      ''\n    ].join('\\n')\n  }\n}\n","import { Node } from '.'\nimport { Transform } from 'stream'\n\nexport const filter = (callback: (node: Node) => boolean) =>\n  new Transform({\n    objectMode: true,\n    autoDestroy: false,\n    transform: function transform(chunk, _encoding, next) {\n      callback(chunk) ? next(null, chunk) : next()\n    }\n  })\n","import multipipe from 'multipipe'\nimport split2 from 'split2'\nimport { createDuplex } from './utils'\nimport { Parser } from './Parser'\n\nexport const parse = () => {\n  const parser = new Parser({\n    push: node => outputStream.push(node)\n  })\n\n  const stream = createDuplex({\n    write(chunk, _encoding, next) {\n      try {\n        parser.parseLine(chunk.toString())\n      } catch (err) {\n        return next(err)\n      }\n\n      next()\n    }\n  })\n\n  const splitStream = split2()\n\n  splitStream.on('finish', () => {\n    parser.flush()\n    stream.push(null)\n  })\n\n  const outputStream = multipipe(splitStream, stream, {\n    objectMode: true\n  })\n\n  return outputStream\n}\n","import { Parser } from './Parser'\nimport { NodeList } from '.'\n\nexport const parseSync = (input: string): NodeList => {\n  const buffer: NodeList = []\n  const parser = new Parser({\n    push: node => buffer.push(node)\n  })\n\n  input\n    .replace(/\\r\\n/g, '\\n')\n    .split('\\n')\n    .forEach(line => parser.parseLine(line))\n\n  parser.flush()\n\n  return buffer\n}\n","import { map, Node } from '.'\n\nexport const resync = (time: number) =>\n  map((node: Node) => {\n    if (node.type === 'cue') {\n      return {\n        ...node,\n        data: {\n          ...node.data,\n          start: node.data.start + time,\n          end: node.data.end + time\n        }\n      }\n    }\n\n    return node\n  })\n","import { map, FormatOptions, Node } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringify = (options: FormatOptions) => {\n  const formatter = new Formatter(options)\n  return map((chunk: Node) => formatter.format(chunk))\n}\n","import { NodeList, FormatOptions } from '.'\nimport { Formatter } from './Formatter'\n\nexport const stringifySync = (\n  list: NodeList,\n  options: FormatOptions\n): string => {\n  const formatter = new Formatter(options)\n\n  return list.reduce((buffer, node) => {\n    return buffer + formatter.format(node)\n  }, '')\n}\n"],"names":["padLeft","value","length","toString","padStart","createDuplex","options","Duplex","objectMode","autoDestroy","read","formatTimestamp","timestamp","format","date","Date","hours","getHours","minutes","getMinutes","seconds","getSeconds","ms","Math","floor","map","mapper","index","Transform","transform","chunk","_encoding","callback","Parser","this","push","state","expect","row","hasContentStarted","isWebVTT","node","buffer","_proto","isIndex","line","test","trim","isTimestamp","RE_TIMESTAMP","isVttComment","getError","expected","Error","parseLine","contents","stripBom","header","parseHeader","id","parseId","parseTimestamp","text","parseText","vtt_comment","parseVttComment","call","flush","pushNode","type","data","parseTimestamps","pop","includes","shift","join","match","parseInt","exec","start","end","settings","Formatter","hasReceivedHeader","isVTT","formatCue","cue","next","parser","outputStream","stream","write","err","splitStream","split2","on","multipipe","input","replace","split","forEach","time","formatter","list","reduce"],"mappings":"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"}